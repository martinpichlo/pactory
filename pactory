# Pacman History - Logfile Parser for pacman.log
# 01.01.2018, Martin Pichlo, First Version
# 16.02.2018, Martin Pichlo, Enhanced command line parameter interpretation
# 19.02.2018, Martin Pichlo, Bugfixing for reinstalled package

#configuration
logfile="/var/log/pacman.log"
string_run="[PACMAN] Running"
string_sot="[ALPM] transaction started"
string_eot="[ALPM] transaction completed"
string_ins="[ALPM] installed"
string_upr="[ALPM] upgraded"
string_rem="[ALPM] removed"
string_rei="reinstalled"

#ersetzen durch "true" und "false" (ohne variable)
true="1"
false="0"

#parameters for read command
IFS=" "					#splitt by space

#declarations
date=""					#Date
expl=""					#Explicit
deps=""					#Dependency
mode=""					#Mode (installed, removed, upgraded, reinstalled)

# command line parameter interpretation
POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    -q|--quite)
    param_quite=true
    shift
    ;;
    -c|--color)
    param_color=true
    shift
    ;;
    -s|--short)
    param_short=true
    shift
    ;;
    -h|--help)
    param_help=true
    shift
    ;;
    *)
    param_search=("$1")
    shift
    ;;
esac
done

usage() {

    echo "Usage: paclog [search] [options] or paclog [options] [search]"
    echo
    echo "Options:"
    echo "-q|--quite        quite output (for reusing in other commands like pacman)"
    echo "-c|--color        colored output"
    echo "-s|--short        short output (one line per transaction)"

    #Usage
    #paclog.sh                      - Prints all commands
    #paclog.sh <regex>              - Regex search in: Date+Mode+Explicit+Packages
    #paclog.sh [regex] <options>    - Options

    #Mode values: {installed, removed, upgraded, reinstalled}

    #regex-Examples
    #paclog.sh "2018-01-01"			- Filter for commands of a date
    #paclog.sh "2018-01-01.*vim		- ... and a package (explicit or deps)
    #paclog.sh "2018-01-01.* inst.*vim 	- ... installed and package (Hint: Space in front of installed exclude reinstalled)

    #Example 1: Select packages and check, if they are installed
    #comm -12 <(pacman -Qq | sort) <(./paclog.sh "installed.*vim" -q | sort)

}

start() {

    #help message
	if [[ "${param_help}" ]]; then
        usage
        exit
    fi

	#parameters for echo
	if [[ "${param_color}" ]]; then
		green=$(tput setaf 2)
		reset=$(tput sgr0)
	fi

	sot="$false"				#Start of Transaction

	while read line
	do

		#Running pacman...
		if [[ "$line" == *"$string_run"* ]]; then
			expl="$line"
			sot="$false"
            continue
		fi

		#transaction started
		if [ -n "$expl" ]; then
			if [[ "$line" == *"$string_sot"* ]]; then
				sot=$true
				#echo "$expl"
				split_pacman "$expl"
				continue
			fi
		fi

		#packages installed, upgraded, removed or reinstalled
		if [ "$sot" == "$true" ]; then

			if [[ "$line" == *"$string_ins"* ]] ||
			   [[ "$line" == *"$string_upr"* ]] ||
			   [[ "$line" == *"$string_rem"* ]] ||
		   	   [[ "$line" == *"$string_rei"* ]]; then
				    split_prog "$line"
		            continue
		        fi
		fi

		#transaction completed
		if [[ "$line" == *"$string_eot"* ]]; then

			if [ -z "${param_search}" ];then
				output
			else
				search="$date $mode $expl $deps"
				if [[ ${search} =~ $param_search ]]; then
					output
				fi
			fi

			date=""
			expl=""
			mode=""
			deps=""
			search=""
        	sot="$false"
			continue
		fi

	done < $logfile

}

split_pacman() {

	#Folgende Zeichen im String lÃ¶schen ', [, ]
	str=$1
	str=${str//\'/}
	str=${str//\[/}
	str=${str//\]/}

	#String nach Leerzeichen aufsplitten
    read -ra array <<< "$str"

	#echo "Pacman Array: ${array[@]}"

	date="${array[0]} ${array[1]}"

	#Array durchlaufen
	options=false
    expl=""
	for i in "${array[@]}"; do

        # check if options were allready read
        if [ "$options" == true ]; then

			if [ -z "$expl" ]; then
				expl="$i"
			else
				expl="$expl $i"
			fi

		fi

        # check for options
        if [[ "${i:0:1}" == "-" ]]; then
            options=true
        fi

	done

}

split_prog() {

	str=$1

    read -ra array <<< "$str"
	prog="${array[4]}"
	mode="${array[3]}"

	#build string with program names
	if [ -z "$deps" ]; then
		deps="$prog"
	else
		deps="$deps $prog"
	fi

}

output() {

	if [[ "${param_quite}" = true ]]; then
		read -ra array <<< "$deps"
		for i in "${array[@]}"; do
			echo $i
		done
		return
	fi

	if [[ "${param_short}" = true ]]; then
		echo "$date | $mode | ${green}$expl${reset} | $deps"
		return
	fi

	echo "Date: $date"
	echo "Mode: $mode"
	echo "Explicit: ${green}$expl${reset}"
	echo "Packages: $deps"
	echo

}

start
